## Two Sum:
不能使用暴力搜索，暴力搜索时间是O(n^2)
如果先遍历一遍数组，将数组中的数与序号相对应存在新的无序数组里，然后在这个数组里找出target与num[i]的差值，这样时间复杂度减少为O(n^2)

## HammingDistance:
对两个数进行异或，再用bin函数转化为二进制（str类型），数出1的个数

## MergeTwoBinaryTree:
迭代思想；
类的使用；
二叉树

## SelfDividingNums:
将数拆分成字符串型；
利用字符串特征来查找数中所含有的0；
再对每个数转换会int型进行模整除判断

## isToeplitzMatrix:
算法复杂度O(N^2)；
利用无序数组查询行坐标与列坐标差所对应的值是否相等

## AddDigts:
**要求**：时间复杂度为O(1)，说明不能用循环；
找数字规律，发现所有整数的数根都是周期为9的循环；
注意题目要求是非负数，包括0

## HappyNums:
如果一个数不是Happy Number，那么它每个数的平方和会形成一个循环；
若周期为N，那么时间复杂度为O(N)

## UglyNums:
遍历整除；
数num对[2,3,5]的模是不是0，不是的话就不是UglyNums

## SpiralMatrix:
螺旋矩阵：
递归求解，先求解外围

## PairSum:
对于一个排好序的数组，最大数对和是顺序组合相邻两个数并求这些组合中最小数的和
因此先对数组排序即可完成该题
但是有O(n)的方法，就是用哈希表法，将值存为地址（自动排好序），再求和

## ComplementNumber:
该题方法是用补码的特征，补码与原码相加等于2^n-1
注意数据类型，当num给的特别大即2^31-1时，那么2^31会超出int类型范围
